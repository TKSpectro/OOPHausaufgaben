//
//
//  Generated by StarUML(tm) C++ Add-In
//
//  @ Project : GruppeC
//  @ File Name : Junction.cpp
//  @ Date : 15.04.2019
//  @ Author : 
//
//

#include "Junction.h"
#include "RoadNetwork.h"
#include "Road.h"
#include <cstring>
#include <vector>

Junction::Junction(const Point2D& position, RoadNetwork& network, const char junctionName[])
	: network(&network)
	, location(position)
	, name(nullptr)
{
	this->name = new char[strlen(junctionName) + 1];
	strcpy(name, junctionName);
	network.add(*this);
}

Junction::~Junction()
{
	this->network->remove(*this);
	// TODO: Was machen wir mit den Straﬂen?
	delete[] this->name;
}

RoadNetwork* Junction::getNetwork() const
{
	return this->network;
}

const char* Junction::getName() const
{
	return this->name;
}

Point2D Junction::getLocation() const
{
	return this->location;
}

void Junction::draw(Drawer2D& drawer) const
{
	this->location.draw(drawer);
}

void Junction::save(std::ofstream& outFile)
{
	//speichern von x, y und den Namen der Junction
	outFile << "Junction" << ";" // keyword
		<< this->getLocation().getX() << ";" // x-value
		<< this->getLocation().getY() << ";" // y-value
		<< this->getName() << ";"; // junctionName
	outFile << "\n";
}

bool Junction::join(Road& road, bool atStart)
{
	if(atStart)
	{
		this->outRoads.push_back(&road);
	}
	else
	{
		this->inRoads.push_back(&road);
	}
	// TODO Test, ob Straﬂe schon angebunden
	return true;
}

bool Junction::disjoin(Road& road, bool atStart)
{
	list<Road*>* pList = &this->inRoads;
	if(atStart)
	{
		pList = &this->outRoads;
	}
	for(list<Road*>::iterator iter = pList->begin(); iter != pList->end(); ++iter)
	{
		if(*iter == &road)
		{
			pList->erase(iter);
			return true;
		}
	}
	return false;
}

