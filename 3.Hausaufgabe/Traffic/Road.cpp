//
//
//  Generated by StarUML(tm) C++ Add-In
//
//  @ Project : GruppeC
//  @ File Name : Road.cpp
//  @ Date : 15.04.2019
//  @ Author : 
//
//

#include "Road.h"
#include "RoadNetwork.h"
#include "Junction.h"
#include "Vehicle.h"
#include <cstring>

Road::Road(Junction& start, Junction& end, const Polyline2D& position, const char roadName[])
	: startNode(&start)
	, endNode(&end)
	, course(position)
	, networks{start.getNetwork(), nullptr}
	, name(nullptr)
{
	// Der Name muss kopiert sein, bevor die Anmeldung beim Netzwerk erfolgt
	this->name = new char[strlen(roadName) + 1];
	strcpy(name, roadName);
	// Teste Konsistenz zwischen Topologie und Geometrie, korrigiere Verlauf erforderlichenfalls
	if(this->startNode->getLocation() != this->course.getStart())
	{
		this->course.insertPoint(this->startNode->getLocation(), 0);
		this->course.removePoint(1);
	}
	if(this->endNode->getLocation() != this->course.getEnd())
	{
		int nPoints = this->course.getNumberOfPoints();
		this->course.insertPoint(this->endNode->getLocation(), nPoints);
		this->course.removePoint(nPoints - 1);
	}
	start.join(*this, true);
	end.join(*this, false);
	networks[0]->add(*this);
	if(end.getNetwork() != this->networks[0])
	{
		this->networks[1] = end.getNetwork();
		networks[1]->add(*this);
	}
}

Road::~Road()
{
	// TODO: Was passiert mit den Fahrzeugen?
	this->startNode->disjoin(*this, true);
	this->endNode->disjoin(*this, false);
	for(RoadNetwork* network : this->networks)
	{
		if(network != nullptr)
		{
			network->remove(*this);
		}
	}
	delete[] this->name;
}

double Road::getLength()
{
	return this->course.getLength();
}

bool Road::addVehicle(Vehicle& veh, bool atStart)
{
	// TODO test auf Vorhandensein
	VehicleInfo entry = {veh.getPosition(), atStart};
	this->vehicles[&veh] = entry;
	veh.road = this;
	return true;
}

bool Road::removeVehicle(Vehicle& veh)
{
	map<const Vehicle*, VehicleInfo>::iterator iter = this->vehicles.find(&veh);
	if(iter != this->vehicles.end())
	{
		this->vehicles.erase(iter);
		return true;
	}
	return false;
}

const char* Road::getName() const
{
	return this->name;
}

void Road::draw(Drawer2D& drawer) const
{
	this->course.draw(drawer);
	for(auto entry : vehicles)
	{
		entry.first->draw(drawer);
	}
}

Junction* Road::getJunction(bool atStart) const
{
	return atStart ? this->startNode : this->endNode;
}

Point2D Road::getPosition(const Vehicle& vehicle) const
{
	map<const Vehicle*, VehicleInfo>::const_iterator iter = this->vehicles.find(&vehicle);
	if(iter != this->vehicles.end())
	{
		double odo = vehicle.getPosition();
		double dist = odo - iter->second.startPosition;
		// Falls das Fahrzeug vom Endknoten her kommt, muss die Entfernung von
		// der Länge abgezogen werden
		if(!iter->second.atStart)
		{
			dist = this->course.getLength() - dist;
		}
		return this->course.getPointAt(dist);
	}

	return Point2D(0, 0, false);
}

void Road::save(std::ofstream& outFile)
{
	outFile << "Road" << ";" // keyword
		<< this->getJunction(true)->getName() << ";" // startJunction
		<< this->getJunction(false)->getName() << ";" // endJunction
		<< this->getName() << ";"; // roadName

	for(unsigned short i = 0; i < this->course.getNumberOfPoints(); i++) //for every point
	{
		outFile << this->course.getPoint(i).getX() << ";"
			<< this->course.getPoint(i).getY() << ";";
	}
	outFile << "\n";
}

