//
//
//  Generated by StarUML(tm) C++ Add-In
//
//  @ Project : GruppeC
//  @ File Name : Road.cpp
//  @ Date : 15.04.2019
//  @ Author : 
//
//

#include "Road.h"
#include "RoadNetwork.h"
#include "Junction.h"
#include "Vehicle.h"
#include <cstring>

Road::Road(Junction& start, Junction& end, const Polyline2D& position, const char roadName[])
	: startNode(&start)
	, endNode(&end)
	, course(position)
	, networks{start.getNetwork(), nullptr}
	, name(nullptr)
{
	// Der Name muss kopiert sein, bevor die Anmeldung beim Netzwerk erfolgt
	this->name = new char[strlen(roadName) + 1];
	strcpy(name, roadName);
	// Teste Konsistenz zwischen Topologie und Geometrie, korrigiere Verlauf erforderlichenfalls
	if (this->startNode->getLocation() != this->course.getStart()) {
		this->course.insertPoint(this->startNode->getLocation(), 0);
		this->course.removePoint(1);
	}
	if (this->endNode->getLocation() != this->course.getEnd()) {
		int nPoints = this->course.getNumberOfPoints();
		this->course.insertPoint(this->endNode->getLocation(), nPoints);
		this->course.removePoint(nPoints - 1);
	}
	start.join(*this, true);
	end.join(*this, false);
	networks[0]->add(*this);
	if (end.getNetwork() != this->networks[0]) {
		this->networks[1] = end.getNetwork();
		networks[1]->add(*this);
	}
}

Road::~Road()
{
	// TODO: Was passiert mit den Fahrzeugen?
	this->startNode->disjoin(*this, true);
	this->endNode->disjoin(*this, false);
	for (RoadNetwork* network : this->networks) {
		if (network != nullptr) {
			network->remove(*this);
		}
	}
	delete[] this->name;
}

double Road::getLength() {
	return this->course.getLength();
}

bool Road::addVehicle(Vehicle& veh, bool atStart) {
	// TODO test auf Vorhandensein
	VehicleInfo entry = {veh.getPosition(), atStart};
	this->vehicles[&veh] = entry;
	veh.road = this;
	return true;
}

bool Road::removeVehicle(Vehicle& veh) {
	map<const Vehicle*, VehicleInfo>::iterator iter = this->vehicles.find(&veh);
	if (iter != this->vehicles.end()) {
		this->vehicles.erase(iter);
		return true;
	}
	return false;
}

const char * Road::getName() const
{
	return this->name;
}

void Road::draw(Drawer2D & drawer) const
{
	this->course.draw(drawer);
	for (auto entry : vehicles) {
		entry.first->draw(drawer);
	}
}

Junction * Road::getJunction(bool atStart) const
{
	return atStart ? this->startNode : this->endNode;
}

Point2D Road::getPosition(const Vehicle & vehicle) const
{
	map<const Vehicle*, VehicleInfo>::const_iterator iter = this->vehicles.find(&vehicle);
	if (iter != this->vehicles.end()) {
		double odo = vehicle.getPosition();
		double dist = odo - iter->second.startPosition;
		// Falls das Fahrzeug vom Endknoten her kommt, muss die Entfernung von
		// der Länge abgezogen werden
		if (!iter->second.atStart) {
			dist = this->course.getLength() - dist;
		}
		return this->course.getPointAt(dist);
	}

	return Point2D(0, 0, false);
}

